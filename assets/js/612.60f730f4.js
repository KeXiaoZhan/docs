(window.webpackJsonp=window.webpackJsonp||[]).push([[612],{1017:function(t,v,_){"use strict";_.r(v);var a=_(58),e=Object(a.a)({},(function(){var t=this,v=t.$createElement,_=t._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h1",{attrs:{id:"概览"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#概览"}},[t._v("#")]),t._v(" 概览")]),t._v(" "),_("p",[t._v("动态规划往往是最能有效考察算法和设计能力的题目类型，面对这类题目最重要的是抓住问题的阶段，了解每个阶段的状态，从而分析阶段之间的关系转化。")]),t._v(" "),_("p",[t._v("适用于动态规划的问题，需要满足最优子结构和无后效性，动态规划的求解过程，在于找到状态转移方程，进行自底向上的求解。")]),t._v(" "),_("p",[_("img",{attrs:{src:"https://gitee.com/wddzhahaha/images/raw/master/img/3roOnqlBDEP5RZN.jpg",alt:"img"}})]),t._v(" "),_("p",[t._v("自底向上的求解，可以帮你省略大量的复杂计算，例如上面的斐波拉契数列，使用递归的话时间复杂度会呈指数型增长，而动态规划则让此算法的时间复杂度保持在"),_("code",[t._v("O(n)")])]),t._v(" "),_("p",[_("strong",[t._v("对于动态规划问题，我将拆解为如下五步曲，这五步都搞清楚了，才能说把动态规划真的掌握了！")])]),t._v(" "),_("ol",[_("li",[t._v("确定dp数组（dp table）以及下标的含义")]),t._v(" "),_("li",[t._v("确定递推公式")]),t._v(" "),_("li",[t._v("dp数组如何初始化")]),t._v(" "),_("li",[t._v("确定遍历顺序")]),t._v(" "),_("li",[t._v("举例推导dp数组")])]),t._v(" "),_("p",[t._v("一些同学可能想为什么要先确定递推公式，然后在考虑初始化呢？")]),t._v(" "),_("p",[_("strong",[t._v("因为一些情况是递推公式决定了dp数组要如何初始化！")])]),t._v(" "),_("h2",{attrs:{id:"动态规划应该如何debug"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#动态规划应该如何debug"}},[t._v("#")]),t._v(" 动态规划应该如何debug")]),t._v(" "),_("p",[t._v("相信动规的题目，很大部分同学都是这样做的。")]),t._v(" "),_("p",[t._v("看一下题解，感觉看懂了，然后照葫芦画瓢，如果能正好画对了，万事大吉，一旦要是没通过，就怎么改都通过不了，对 dp数组的初始化，递推公式，遍历顺序，处于一种黑盒的理解状态。")]),t._v(" "),_("p",[t._v("写动规题目，代码出问题很正常！")]),t._v(" "),_("p",[_("strong",[t._v("找问题的最好方式就是把dp数组打印出来，看看究竟是不是按照自己思路推导的！")])])])}),[],!1,null,null,null);v.default=e.exports}}]);